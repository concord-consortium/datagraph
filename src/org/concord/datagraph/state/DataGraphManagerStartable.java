/**
 * 
 */
package org.concord.datagraph.state;

import java.util.ArrayList;

import org.concord.datagraph.engine.DataGraphable;
import org.concord.framework.data.stream.DataProducer;
import org.concord.framework.data.stream.DataStore;
import org.concord.framework.data.stream.DefaultMultipleDataProducer;
import org.concord.framework.startable.AbstractStartable;
import org.concord.framework.startable.StartableInfo;

class DataGraphManagerStartable extends AbstractStartable {
	/**
	 * 
	 */
	private final DataGraphManager dataGraphManager;
	private StartableInfo info = new StartableInfo();

	/**
	 * @param dataGraphManager
	 */
	DataGraphManagerStartable(DataGraphManager dataGraphManager) {
		this.dataGraphManager = dataGraphManager;
		updateInfo();
	}

	public boolean isRunning() {
		// see if there are any data producers running in the graph
		return dataGraphManager.dataGraph.getRunningDataProducers().size() > 0;
	}

	@Override
	public boolean isInInitialState() {				
		if (dataGraphManager.sourceGraphable != null) {
			DataStore dataStore = dataGraphManager.sourceGraphable.getDataStore();
			if (dataStore.getTotalNumSamples() > 0) {
				return false;
			}
		}				
		return true;
	}

	public void reset() {
		// We bypass the normal dataGraph reset method so only the
		// selected graphable is cleared.
		if (dataGraphManager.sourceGraphable != null) {
			dataGraphManager.sourceGraphable.reset();
		}
		
		// sfentress: If our data producer is a MultipleDataProducer, 
		// clear should clear all data lines that are being actively 
		// generated by that data producer, including any graphables 
		// with the same producer
		DataProducer dp = dataGraphManager.getSourceDataProducer();
		if (dp instanceof DefaultMultipleDataProducer) {
			if (((DefaultMultipleDataProducer) dp).getClearAll()){
				ArrayList<DataGraphable> graphablesToReset = dataGraphManager.getDataGraph().getAllGraphables(dp);
				for (int i = 0; i < graphablesToReset.size(); i++) {
	               graphablesToReset.get(i).reset();
	            }
			}
		}

		if(dp != null) {
			dp.reset();
		}
				
		if (dataGraphManager.dataGraph.isAdjustOriginOffsetOnReset()){
		    dataGraphManager.dataGraph.resetGraphArea();
		}
		
		notifyReset();
	}

	public void start() {
		dataGraphManager.dataGraph.start();
		DataProducer sourceDataProducer = dataGraphManager.getSourceDataProducer();
		if(sourceDataProducer != null){
			sourceDataProducer.start();
		}
		notifyStarted(isInInitialState());
	}

	public void stop() {
		dataGraphManager.dataGraph.stop();
		DataProducer sourceDataProducer = dataGraphManager.getSourceDataProducer();
		if(sourceDataProducer != null){
			sourceDataProducer.stop();
		}
		
		// This might not be necessary but it can't hurt
		DataProducer oldSourceDataProducer = dataGraphManager.sourceGraphable.findDataProducer();
		if(oldSourceDataProducer != null && 
				oldSourceDataProducer != sourceDataProducer){
			oldSourceDataProducer.stop();
		}
		
		// and finally we stop all of the running data producers. 
		ArrayList<DataProducer> runningDataProducers = dataGraphManager.dataGraph.getRunningDataProducers();
		for (DataProducer dataProducer : runningDataProducers) {
			dataProducer.stop();					
		}
		notifyStopped();
	}

	@Override
	public StartableInfo getStartableInfo() {
		return info;
	}
	
	public void update() {
		updateInfo();
		
		notifyUpdated();
	}
	
	protected void updateInfo() {
		info.resetVerb = "Clear";
		if (dataGraphManager.sourceGraphable != null &&
				(dataGraphManager.sourceGraphable.isLocked() ||
				!dataGraphManager.sourceGraphable.isVisible())) {
			info.enabled = false;
		} else {
			info.enabled = true;
		}
		info.sendsEvents = true;
		info.startStopLabel = "collecting data";
		info.resetLabel = "collected data";
	}
}